{"version":3,"sources":["file:///C:/Users/admin/NewProject_18/assets/Scripts/External/immer/immer.ts"],"names":["castDraft","value","castImmutable","Immer","Draft","Immutable","Patch","PatchListener","original","isDraft","isDraftable","NOTHING","DRAFTABLE","enableES5","enablePatches","enableMapSet","enableAllPlugins","immer","produce","produceWithPatches","bind","setAutoFreeze","setUseProxies","applyPatches","createDraft","finishDraft"],"mappings":";;;;;AA0FA;AACA;AACA;AACA;AACA;AACA;AACO,WAASA,SAAT,CAAsBC,KAAtB,EAA0C;AAChD,WAAOA,KAAP;AACA;AAED;AACA;AACA;AACA;AACA;;;AACO,WAASC,aAAT,CAA0BD,KAA1B,EAAkD;AACxD,WAAOA,KAAP;AACA;;;;;;;;;;;;;;;;;;;;;;;eAXeD,S;mBASAE;;;;;;;;;AAtGfC,MAAAA,K,iBAAAA,K;;;6BAMAC,K;iCACAC,S;6BACAC,K;qCACAC,a;gCACAC,Q;+BACAC,O;mCACAC,W;+BACAC,O;iCACAC;;;yCA8FOC,S;;6CACAC,a;;4CACAC,Y;;gDACAC,gB;;;;;;;AA9FFC,MAAAA,K,GAAQ;AAAA;AAAA,2B;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;yBACaC,O,GAAoBD,KAAK,CAACC,O;;yBACxBA,O;AAEf;AACA;AACA;AACA;;;oCACaC,kB,GAA0CF,KAAK,CAACE,kBAAN,CAAyBC,IAAzB,CACtDH,KADsD,C;AAIvD;AACA;AACA;AACA;AACA;;;+BACaI,a,GAAgBJ,KAAK,CAACI,aAAN,CAAoBD,IAApB,CAAyBH,KAAzB,C;AAE7B;AACA;AACA;AACA;AACA;AACA;;;+BACaK,a,GAAgBL,KAAK,CAACK,aAAN,CAAoBF,IAApB,CAAyBH,KAAzB,C;AAE7B;AACA;AACA;AACA;AACA;;;8BACaM,Y,GAAeN,KAAK,CAACM,YAAN,CAAmBH,IAAnB,CAAwBH,KAAxB,C;AAE5B;AACA;AACA;AACA;;;6BACaO,W,GAAcP,KAAK,CAACO,WAAN,CAAkBJ,IAAlB,CAAuBH,KAAvB,C;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;6BACaQ,W,GAAcR,KAAK,CAACQ,WAAN,CAAkBL,IAAlB,CAAuBH,KAAvB,C;;uBAqBnBd,K","sourcesContent":["import {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\nexport {\n\tDraft,\n\tImmutable,\n\tPatch,\n\tPatchListener,\n\toriginal,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable\n} from \"./internal\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = immer.produce\nexport default produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * By default, auto-freezing is disabled in production.\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\nexport const setUseProxies = immer.setUseProxies.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\nexport function castDraft<T>(value: T): Draft<T> {\n\treturn value as any\n}\n\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\nexport function castImmutable<T>(value: T): Immutable<T> {\n\treturn value as any\n}\n\nexport {Immer}\n\nexport {enableES5} from \"./plugins/es5\"\nexport {enablePatches} from \"./plugins/patches\"\nexport {enableMapSet} from \"./plugins/mapset\"\nexport {enableAllPlugins} from \"./plugins/all\"\n"]}