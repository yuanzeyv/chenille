{"version":3,"sources":["file:///C:/Users/admin/NewProject_18/assets/Scripts/External/immer/utils/env.ts"],"names":["Nothing","mini","hasSymbol","Symbol","hasMap","Map","hasSet","Set","hasProxies","Proxy","revocable","Reflect","isMinified","name","NOTHING","DRAFTABLE","DRAFT_STATE","iteratorSymbol","iterator"],"mappings":";;;iBA8CaA,O;;AAhCb;AACA,WAASC,IAAT,GAAgB,CAAE;;;;;;;;;;;;;AAflB;AAEA;AAEA;AACMC,MAAAA,S,GACL,OAAOC,MAAP,KAAkB,WAAlB,IAAiC,OAAOA,MAAM,CAAC,GAAD,CAAb,KAAuB,Q;;wBAC5CC,M,GAAS,OAAOC,GAAP,KAAe,W;;wBACxBC,M,GAAS,OAAOC,GAAP,KAAe,W;;4BACxBC,U,GACZ,OAAOC,KAAP,KAAiB,WAAjB,IACA,OAAOA,KAAK,CAACC,SAAb,KAA2B,WAD3B,IAEA,OAAOC,OAAP,KAAmB,W;;4BAIPC,U,GAAaX,IAAI,CAACY,IAAL,KAAc,M;AAExC;AACA;AACA;;;yBACaC,O,GAAmBZ,SAAS,GACtCC,MAAM,CAAC,eAAD,CADgC,GAErC;AAAC,SAAC,eAAD,GAAmB;AAApB,O;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;2BACaY,S,GAA2Bb,SAAS,GAC9CC,MAAM,CAAC,iBAAD,CADwC,GAE7C,oB;;6BAESa,W,GAA6Bd,SAAS,GAChDC,MAAM,CAAC,aAAD,CAD0C,GAE/C,gB,GAEJ;;;gCACac,c,GACX,OAAOd,MAAP,IAAiB,WAAjB,IAAgCA,MAAM,CAACe,QAAxC,IAAsD,Y;AAEvD;;;yBACalB,O,GAAN,MAAMA,OAAN,CAAc,E","sourcesContent":["// Should be no imports here!\n\n// Some things that should be evaluated before all else...\n\n// We only want to know if non-polyfilled symbols are available\nconst hasSymbol =\n\ttypeof Symbol !== \"undefined\" && typeof Symbol(\"x\") === \"symbol\"\nexport const hasMap = typeof Map !== \"undefined\"\nexport const hasSet = typeof Set !== \"undefined\"\nexport const hasProxies =\n\ttypeof Proxy !== \"undefined\" &&\n\ttypeof Proxy.revocable !== \"undefined\" &&\n\ttypeof Reflect !== \"undefined\"\n\n/* istanbul ignore next */\nfunction mini() {}\nexport const isMinified = mini.name !== \"mini\"\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: Nothing = hasSymbol\n\t? Symbol(\"immer-nothing\")\n\t: ({[\"immer-nothing\"]: true} as any)\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = hasSymbol\n\t? Symbol(\"immer-draftable\")\n\t: (\"__$immer_draftable\" as any)\n\nexport const DRAFT_STATE: unique symbol = hasSymbol\n\t? Symbol(\"immer-state\")\n\t: (\"__$immer_state\" as any)\n\n// Even a polyfilled Symbol might provide Symbol.iterator\nexport const iteratorSymbol: typeof Symbol.iterator =\n\t(typeof Symbol != \"undefined\" && Symbol.iterator) || (\"@@iterator\" as any)\n\n/** Use a class type for `nothing` so its type is unique */\nexport class Nothing {\n\t// This lets us do `Exclude<T, Nothing>`\n\t// @ts-ignore\n\tprivate _!: unique symbol\n}\n"]}