{"version":3,"sources":["file:///C:/Users/admin/NewProject_18/assets/External/BTree/index.ts"],"names":["_resetFinalStates","node","root","type","NodeType","Action","getValue","_StoreKey","WasRun","setValue","Status","NodeStatus","Ready","Portal","Invert","Parallel","Sequence","Selector","children","Array","isArray","hasRunningChildren","some","item","Running","isSequence","hasSequenceFinished","SequenceIndex","length","forEach","i","_interpret","options","props","setState","state","status","patches","Patches","nextState","undefined","Success","tick","bump","draft","fn","isPromise","Condition","exec","Failure","State","Decorator","decorator","states","parent","nSuccess","filter","nFailure","index","child","Error","currentValue","Count","createNodeState","customState","$nodeState","key","value","defaultValue","then","nanoid","produce","applyPatches","enablePatches","nodes","name","childrenFactory","initialState","registrations","getListeners","id","Root","window","dispatchEvent","CustomEvent","nodeStatus","addEventListener","listener","listeners","indexOf","push","removeEventListener","splice","event","slice","call","defaultPrevented","bind","selector","sequence","parallel","condition","args","portal","clear","mount","find","unmount","findIndex","invert","action"],"mappings":";;;;;;;AAoVA,WAASA,iBAAT,CACEC,IADF,EAEEC,IAFF,EAGE;AACA,YAAQD,IAAI,CAACE,IAAb;AACE,WAAKC,QAAQ,CAACC,MAAd;AACE,YAAI,CAACJ,IAAI,CAACK,QAAL,CAAcC,SAAS,CAACC,MAAxB,CAAL,EAAsC;AACpCP,UAAAA,IAAI,CAACQ,QAAL,CAAcF,SAAS,CAACG,MAAxB,EAAgCC,UAAU,CAACC,KAA3C;AACD;;AACD;;AACF,WAAKR,QAAQ,CAACS,MAAd;AACA,WAAKT,QAAQ,CAACU,MAAd;AACA,WAAKV,QAAQ,CAACW,QAAd;AACA,WAAKX,QAAQ,CAACY,QAAd;AACA,WAAKZ,QAAQ,CAACa,QAAd;AAAwB;AACtB;AAEA,cAAMC,SAAQ,GAAGC,KAAK,CAACC,OAAN,CAAcnB,IAAI,CAACiB,QAAnB,IACbjB,IAAI,CAACiB,QADQ,GAEb,CAACjB,IAAI,CAACiB,QAAN,CAFJ;;AAGA,cAAMG,kBAAkB,GAAGH,SAAQ,CAACI,IAAT,CACzBC,IAAI,IAAIA,IAAI,CAACjB,QAAL,CAAcC,SAAS,CAACG,MAAxB,MAAoCC,UAAU,CAACa,OAD9B,CAA3B;;AAGA,cAAMC,UAAU,GAAGxB,IAAI,CAACE,IAAL,KAAcC,QAAQ,CAACY,QAA1C;AACA,cAAMU,mBAAmB,GAAGD,UAAU,GAClCxB,IAAI,CAACK,QAAL,CAAsBC,SAAS,CAACoB,aAAhC,IAAiD,CAAjD,KACET,SAAQ,CAACU,MADX,IACqB3B,IAAI,CAACK,QAAL,CAAcC,SAAS,CAACC,MAAxB,MAAoC,KAFvB,GAGlC,IAHJ;;AAKA,cAAI,CAACa,kBAAD,IAAuBK,mBAA3B,EAAgD;AAC9CzB,YAAAA,IAAI,CAACQ,QAAL,CAAcF,SAAS,CAACG,MAAxB,EAAgCC,UAAU,CAACC,KAA3C;;AAEA,gBAAIX,IAAI,CAACE,IAAL,KAAcC,QAAQ,CAACY,QAA3B,EAAqC;AACnCf,cAAAA,IAAI,CAACQ,QAAL,CAAcF,SAAS,CAACoB,aAAxB,EAAuC,CAAvC;AACD;;AAEDT,YAAAA,SAAQ,CAACW,OAAT,CAAiBN,IAAI,IAAI;AACvBA,cAAAA,IAAI,CAACd,QAAL,CAAcF,SAAS,CAACG,MAAxB,EAAgCC,UAAU,CAACC,KAA3C;AACD,aAFD;AAGD;;AAED,eAAK,IAAIkB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGZ,SAAQ,CAACU,MAA7B,EAAqCE,CAAC,EAAtC,EAA0C;AACxC9B,YAAAA,iBAAiB,CAACkB,SAAQ,CAACY,CAAD,CAAT,EAAc5B,IAAd,CAAjB;AACD;;AACD;AACD;;AACD;AACE;AA3CJ;;AA8CAD,IAAAA,IAAI,CAACQ,QAAL,CAAcF,SAAS,CAACC,MAAxB,EAAgC,KAAhC;AACD;;AAED,WAASuB,UAAT,CACE9B,IADF,EAEEC,IAFF,EAGE8B,OAHF,EAOc;AAAA,QAJZA,OAIY;AAJZA,MAAAA,OAIY,GAJe;AACzBC,QAAAA,KAAK,EAAE,EADkB;AAEzBC,QAAAA,QAAQ,EAAE,MAAM,CAAE;AAFO,OAIf;AAAA;;AACZ,QAAM;AAACC,MAAAA;AAAD,QAAUjC,IAAhB;AACAD,IAAAA,IAAI,CAACQ,QAAL,CAAcF,SAAS,CAACC,MAAxB,EAAgC,IAAhC;;AAEA,YAAQP,IAAI,CAACE,IAAb;AACE,WAAKC,QAAQ,CAACC,MAAd;AAAsB;AACpB,cAAM+B,OAAM,GAAGnC,IAAI,CAACK,QAAL,CAA0BC,SAAS,CAACG,MAApC,CAAf,CADoB,CAGpB;;;AACA,cAAI0B,OAAM,KAAKzB,UAAU,CAACa,OAA1B,EAAmC;AACjC,gBAAMa,OAAO,GAAGpC,IAAI,CAACK,QAAL,CAAuBC,SAAS,CAAC+B,OAAjC,CAAhB,CADiC,CAGjC;;AACA,gBAAID,OAAJ,EAAa;AACX;AACA,kBAAME,UAAS,GAAG;AAAA;AAAA,gDAAaJ,KAAb,EAAoBE,OAApB,CAAlB,CAFW,CAGX;;;AACApC,cAAAA,IAAI,CAACQ,QAAL,CAAcF,SAAS,CAAC+B,OAAxB,EAAiCE,SAAjC;AACAvC,cAAAA,IAAI,CAACQ,QAAL,CAAcF,SAAS,CAACG,MAAxB,EAAgCC,UAAU,CAAC8B,OAA3C;AACAvC,cAAAA,IAAI,CAACiC,KAAL,GAAaI,UAAb;AACAP,cAAAA,OAAO,CAACE,QAAR,oBAAAF,OAAO,CAACE,QAAR,CAAmBK,UAAnB;AACArC,cAAAA,IAAI,CAACwC,IAAL,CAAUV,OAAO,CAACC,KAAlB;AAEA,qBAAOtB,UAAU,CAAC8B,OAAlB;AACD;;AAED,mBAAOL,OAAP;AACD;;AAEDO,UAAAA,IAAI,CAAC1C,IAAD,CAAJ;AAEA,cAAMsC,SAAS,GAAG;AAAA;AAAA,kCAChBJ,KADgB,EAEhBS,KAAK,IAAI3C,IAAI,CAAC4C,EAAL,CAAQD,KAAR,EAAwBZ,OAAO,CAACC,KAAR,IAAkB,EAA1C,CAFO,EAGhBI,OAAO,IAAI;AACTpC,YAAAA,IAAI,CAACQ,QAAL,CAAcF,SAAS,CAAC+B,OAAxB,EAAiCD,OAAjC;;AAEA,gBAAIS,SAAS,CAACP,SAAD,CAAb,EAA0B;AACxBrC,cAAAA,IAAI,CAACwC,IAAL;AACD;AACF,WATe,CAAlB;;AAYA,cAAII,SAAS,CAACP,SAAD,CAAb,EAA0B;AACxBtC,YAAAA,IAAI,CAACQ,QAAL,CAAcF,SAAS,CAACG,MAAxB,EAAgCC,UAAU,CAACa,OAA3C;AAEA,mBAAOb,UAAU,CAACa,OAAlB;AACD,WA1CmB,CA4CpB;;;AAEAtB,UAAAA,IAAI,CAACiC,KAAL,GAAaI,SAAb;AACAP,UAAAA,OAAO,CAACE,QAAR,oBAAAF,OAAO,CAACE,QAAR,CAAmBK,SAAnB;AACAtC,UAAAA,IAAI,CAACQ,QAAL,CAAcF,SAAS,CAACG,MAAxB,EAAgCC,UAAU,CAAC8B,OAA3C;AACA,iBAAO9B,UAAU,CAAC8B,OAAlB;AACD;;AACD,WAAKrC,QAAQ,CAAC2C,SAAd;AAAyB;AACvBJ,UAAAA,IAAI,CAAC1C,IAAD,CAAJ;AACAA,UAAAA,IAAI,CAACQ,QAAL,CAAcF,SAAS,CAACG,MAAxB,EAAgCC,UAAU,CAACa,OAA3C;;AACA,cACEvB,IAAI,CAAC+C,IAAL,CACE;AACEb,YAAAA,KADF;AAEElC,YAAAA,IAFF;AAGEC,YAAAA;AAHF,WADF,EAME8B,OAAO,CAACC,KAAR,IAAkB,EANpB,CADF,EASE;AACAhC,YAAAA,IAAI,CAACQ,QAAL,CAAcF,SAAS,CAACG,MAAxB,EAAgCC,UAAU,CAAC8B,OAA3C;AACA,mBAAO9B,UAAU,CAAC8B,OAAlB;AACD,WAZD,MAYO;AACLxC,YAAAA,IAAI,CAACQ,QAAL,CAAcF,SAAS,CAACG,MAAxB,EAAgCC,UAAU,CAACsC,OAA3C;AACA,mBAAOtC,UAAU,CAACsC,OAAlB;AACD;AACF;;AACD,WAAK7C,QAAQ,CAACU,MAAd;AAAsB;AACpB6B,UAAAA,IAAI,CAAC1C,IAAD,CAAJ;AACAA,UAAAA,IAAI,CAACQ,QAAL,CAAcF,SAAS,CAACG,MAAxB,EAAgCC,UAAU,CAACa,OAA3C;;AACA,cAAMY,QAAM,GAAGL,UAAU,CAAC9B,IAAI,CAACiB,QAAN,EAAgBhB,IAAhB,EAAsB8B,OAAtB,CAAzB;;AACA,cAAII,QAAM,KAAKzB,UAAU,CAACsC,OAA1B,EAAmC;AACjChD,YAAAA,IAAI,CAACQ,QAAL,CAAcF,SAAS,CAACG,MAAxB,EAAgCC,UAAU,CAAC8B,OAA3C;AACA,mBAAO9B,UAAU,CAAC8B,OAAlB;AACD;;AACD,cAAIL,QAAM,KAAKzB,UAAU,CAAC8B,OAA1B,EAAmC;AACjCxC,YAAAA,IAAI,CAACQ,QAAL,CAAcF,SAAS,CAACG,MAAxB,EAAgCC,UAAU,CAACsC,OAA3C;AACA,mBAAOtC,UAAU,CAACsC,OAAlB;AACD;;AACD,iBAAOb,QAAP;AACD;;AACD,WAAKhC,QAAQ,CAAC8C,KAAd;AAAqB;AACnBP,UAAAA,IAAI,CAAC1C,IAAD,CAAJ;AACA,iBAAO8B,UAAU,CAAC9B,IAAI,CAACiB,QAAN,EAAgBhB,IAAhB,EAAsB8B,OAAtB,CAAjB;AACD;;AACD,WAAK5B,QAAQ,CAAC+C,SAAd;AAAyB;AACvBR,UAAAA,IAAI,CAAC1C,IAAD,CAAJ;AACA,iBAAOA,IAAI,CAACmD,SAAL,CAAerB,UAAU,CAAC9B,IAAI,CAACiB,QAAN,EAAgBhB,IAAhB,EAAsB8B,OAAtB,CAAzB,CAAP;AACD;;AACD,WAAK5B,QAAQ,CAACS,MAAd;AACA,WAAKT,QAAQ,CAACW,QAAd;AAAwB;AACtB4B,UAAAA,IAAI,CAAC1C,IAAD,CAAJ;AACAA,UAAAA,IAAI,CAACQ,QAAL,CAAcF,SAAS,CAACG,MAAxB,EAAgCC,UAAU,CAACa,OAA3C;AACA,cAAI6B,MAAM,GAAG,EAAb;;AAEA,eAAK,IAAIvB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG7B,IAAI,CAACiB,QAAL,CAAcU,MAAlC,EAA0CE,CAAC,EAA3C,EAA+C;AAC7C7B,YAAAA,IAAI,CAACiB,QAAL,CAAcY,CAAd,EAAiBwB,MAAjB,GAA0BrD,IAA1B;AACAoD,YAAAA,MAAM,CAACvB,CAAD,CAAN,GAAYC,UAAU,CAAC9B,IAAI,CAACiB,QAAL,CAAcY,CAAd,CAAD,EAAmB5B,IAAnB,EAAyB8B,OAAzB,CAAtB;AACD,WARqB,CAStB;;;AACA,cAAMuB,QAAQ,GAAGF,MAAM,CAACG,MAAP,CAAcpB,MAAM,IAAIA,MAAM,KAAKzB,UAAU,CAAC8B,OAA9C,EACdb,MADH,CAVsB,CAYtB;;AACA,cAAM6B,QAAQ,GAAGJ,MAAM,CAACG,MAAP,CAAcpB,MAAM,IAAIA,MAAM,KAAKzB,UAAU,CAACsC,OAA9C,EACdrB,MADH;;AAGA,cAAI2B,QAAQ,KAAKtD,IAAI,CAACiB,QAAL,CAAcU,MAA/B,EAAuC;AACrC3B,YAAAA,IAAI,CAACQ,QAAL,CAAcF,SAAS,CAACG,MAAxB,EAAgCC,UAAU,CAAC8B,OAA3C;AACA,mBAAO9B,UAAU,CAAC8B,OAAlB;AACD,WAHD,MAGO,IAAIgB,QAAQ,KAAKxD,IAAI,CAACiB,QAAL,CAAcU,MAA/B,EAAuC;AAC5C3B,YAAAA,IAAI,CAACQ,QAAL,CAAcF,SAAS,CAACG,MAAxB,EAAgCC,UAAU,CAACsC,OAA3C;AACA,mBAAOtC,UAAU,CAACsC,OAAlB;AACD;;AACDhD,UAAAA,IAAI,CAACQ,QAAL,CAAcF,SAAS,CAACG,MAAxB,EAAgCC,UAAU,CAACa,OAA3C;AACA,iBAAOb,UAAU,CAACa,OAAlB;AACD;;AACD,WAAKpB,QAAQ,CAACY,QAAd;AAAwB;AACtB2B,UAAAA,IAAI,CAAC1C,IAAD,CAAJ;AACAA,UAAAA,IAAI,CAACQ,QAAL,CAAcF,SAAS,CAACG,MAAxB,EAAgCC,UAAU,CAACa,OAA3C;AACA,cAAIkC,KAAK,GAAGzD,IAAI,CAACK,QAAL,CAAsBC,SAAS,CAACoB,aAAhC,EAA+C,CAA/C,CAAZ;;AACA,iBAAO+B,KAAK,GAAGzD,IAAI,CAACiB,QAAL,CAAcU,MAA7B,EAAqC;AACnC,gBAAM+B,KAAK,GAAG1D,IAAI,CAACiB,QAAL,CAAcwC,KAAd,CAAd;AACAC,YAAAA,KAAK,CAACL,MAAN,GAAerD,IAAf;;AACA,gBAAMmC,QAAM,GAAGL,UAAU,CAAC4B,KAAD,EAAQzD,IAAR,EAAc8B,OAAd,CAAzB;;AAEA,gBAAII,QAAM,KAAKzB,UAAU,CAAC8B,OAA1B,EAAmC;AACjCxC,cAAAA,IAAI,CAACQ,QAAL,CAAcF,SAAS,CAACoB,aAAxB,EAAuC,EAAE+B,KAAzC;AACA;AACD,aAHD,MAGO,IAAItB,QAAM,KAAKzB,UAAU,CAACa,OAA1B,EAAmC;AACxCvB,cAAAA,IAAI,CAACQ,QAAL,CAAcF,SAAS,CAACG,MAAxB,EAAgCC,UAAU,CAACa,OAA3C;AACA,qBAAOb,UAAU,CAACa,OAAlB;AACD,aAHM,MAGA,IAAIY,QAAM,KAAKzB,UAAU,CAACsC,OAA1B,EAAmC;AACxChD,cAAAA,IAAI,CAACQ,QAAL,CAAcF,SAAS,CAACoB,aAAxB,EAAuC,CAAvC;AACA1B,cAAAA,IAAI,CAACQ,QAAL,CAAcF,SAAS,CAACG,MAAxB,EAAgCC,UAAU,CAACsC,OAA3C;AACA,qBAAOtC,UAAU,CAACsC,OAAlB;AACD;AACF;;AACDhD,UAAAA,IAAI,CAACQ,QAAL,CAAcF,SAAS,CAACoB,aAAxB,EAAuC,CAAvC;AACA1B,UAAAA,IAAI,CAACQ,QAAL,CAAcF,SAAS,CAACG,MAAxB,EAAgCC,UAAU,CAAC8B,OAA3C;AACA,iBAAO9B,UAAU,CAAC8B,OAAlB;AACD;;AACD,WAAKrC,QAAQ,CAACa,QAAd;AAAwB;AACtB0B,UAAAA,IAAI,CAAC1C,IAAD,CAAJ;AACAA,UAAAA,IAAI,CAACQ,QAAL,CAAcF,SAAS,CAACG,MAAxB,EAAgCC,UAAU,CAACa,OAA3C;;AAEA,eAAK,IAAMmC,MAAX,IAAoB1D,IAAI,CAACiB,QAAzB,EAAmC;AACjCyC,YAAAA,MAAK,CAACL,MAAN,GAAerD,IAAf;;AACA,gBAAMmC,QAAM,GAAGL,UAAU,CAAC4B,MAAD,EAAQzD,IAAR,EAAc8B,OAAd,CAAzB;;AACA,gBAAII,QAAM,KAAKzB,UAAU,CAAC8B,OAAtB,IAAiCL,QAAM,KAAKzB,UAAU,CAACa,OAA3D,EAAoE;AAClEvB,cAAAA,IAAI,CAACQ,QAAL,CAAcF,SAAS,CAACG,MAAxB,EAAgC0B,QAAhC;AACA,qBAAOA,QAAP;AACD;AACF;;AACDnC,UAAAA,IAAI,CAACQ,QAAL,CAAcF,SAAS,CAACG,MAAxB,EAAgCC,UAAU,CAACsC,OAA3C;AACA,iBAAOtC,UAAU,CAACsC,OAAlB;AACD;;AACD;AACE,cAAM,IAAIW,KAAJ,CAAU,oBAAV,CAAN;AAlKJ;AAoKD;;AAED,WAASjB,IAAT,CAAc1C,IAAd,EAAwC;AACtC,QAAM4D,YAAY,GAAG5D,IAAI,CAACK,QAAL,CAAsBC,SAAS,CAACuD,KAAhC,EAAuC,CAAvC,CAArB;AACA7D,IAAAA,IAAI,CAACQ,QAAL,CAAcF,SAAS,CAACuD,KAAxB,EAA+BD,YAAY,GAAG,CAA9C;AACD;;AAED,WAASE,eAAT,CAAyBC,WAAzB,EAA4C;AAC1C,WAAO;AACLC,MAAAA,UAAU;AACR,SAAC1D,SAAS,CAACuD,KAAX,GAAmB,CADX;AAER,SAACvD,SAAS,CAACC,MAAX,GAAoB,KAFZ;AAGR,SAACD,SAAS,CAACG,MAAX,GAAoBC,UAAU,CAACC;AAHvB,SAILoD,WAJK,CADL;;AAOLvD,MAAAA,QAAQ,CAACyD,GAAD,EAAcC,KAAd,EAA0B;AAChC,aAAK,YAAL,EAAmBD,GAAnB,IAA0BC,KAA1B;AACD,OATI;;AAUL7D,MAAAA,QAAQ,CAAQ4D,GAAR,EAAqBE,YAArB,EAAgD;AACtD,YAAI,KAAK,YAAL,MAAuB5B,SAA3B,EAAsC;AACpC,iBAAO4B,YAAY,KAAK5B,SAAjB,GAA6BA,SAA7B,GAAyC4B,YAAhD;AACD;;AACD,eAAO,KAAK,YAAL,EAAmBF,GAAnB,MAA4B1B,SAA5B,GACH4B,YADG,GAEH,KAAK,YAAL,EAAmBF,GAAnB,CAFJ;AAGD;;AAjBI,KAAP;AAmBD;;AAED,WAASpB,SAAT,CAAmBvB,IAAnB,EAAuC;AACrC,WAAOA,IAAI,IAAI,OAAOA,IAAI,CAAC8C,IAAZ,KAAqB,UAApC;AACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAvlBMC,MAAAA,M;;AACAC,MAAAA,O;AAAUC,MAAAA,Y,UAAAA,Y;AAAqBC,MAAAA,a,UAAAA,a;;;;;;;AAEtC;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uBAuJaC,K,GAAQ;AACnBxE,QAAAA,IAAI,EAAE,cACJyE,IADI,EAEJC,eAFI,EAGJ;AAAA;;AACA,iBAAO,UACLC,YADK,EAEL7C,OAFK,EAMuB;AAAA,gBAJ5BA,OAI4B;AAJ5BA,cAAAA,OAI4B,GAJD;AACzBC,gBAAAA,KAAK,EAAE,EADkB;AAEzBC,gBAAAA,QAAQ,EAAE,MAAM,CAAE;AAFO,eAIC;AAAA;;AAC5B,gBAAM4C,aAEL,GAAG,EAFJ;;AAGA,gBAAMC,YAAY,GAAG,SAAfA,YAAe,CAAS5E,IAAT,EAAuB;AAC1C,kBAAI,EAAEA,IAAI,IAAI2E,aAAV,CAAJ,EAA8BA,aAAa,CAAC3E,IAAD,CAAb,GAAsB,EAAtB;AAC9B,qBAAO2E,aAAa,CAAC3E,IAAD,CAApB;AACD,aAHD;;AAIA,gBAAMD,IAA6B;AACjC8E,cAAAA,EAAE,EAAE;AAAA;AAAA,qCAD6B;AAEjCL,cAAAA,IAFiC;AAGjCxE,cAAAA,IAAI,EAAEC,QAAQ,CAAC6E,IAHkB;AAIjC/D,cAAAA,QAAQ,EAAE0D,eAAe,EAJQ;AAKjCzC,cAAAA,KAAK,EAAE0C,YAL0B;AAMjCnC,cAAAA,IAAI,EAAE,SAASA,IAAT,CAAcT,KAAd,EAA6B;AACjC,oBAAI,OAAOiD,MAAP,KAAkB,WAAtB,EAAmC;AACjC,yBAAO1C,SAAP;AACD;;AACD,qBAAK2C,aAAL,CAAmB,IAAIC,WAAJ,CAAgB,WAAhB,CAAnB;;AACA,oBAAMC,UAAU,GAAGtD,UAAU,CAAC,KAAKb,QAAN,EAAgB,IAAhB,eACxBc,OADwB;AAE3BC,kBAAAA;AAF2B,mBAA7B;;AAIAjC,gBAAAA,iBAAiB,CAAC,KAAKkB,QAAN,EAAgB,IAAhB,CAAjB;;AACA,qBAAKiE,aAAL,CAAmB,IAAIC,WAAJ,CAAgB,SAAhB,CAAnB;AACA,uBAAOC,UAAP;AACD,eAlBgC;AAmBjCC,cAAAA,gBAAgB,EAAE,CAChBnF,IADgB,EAEhBoF,QAFgB,KAGb;AACH,oBAAMC,SAAS,GAAGT,YAAY,CAAC5E,IAAD,CAA9B;AACA,oBAAMuD,KAAK,GAAG8B,SAAS,CAACC,OAAV,CAAkBF,QAAlB,CAAd;AACA,oBAAI7B,KAAK,KAAK,CAAC,CAAf,EAAkBoB,aAAa,CAAC3E,IAAD,CAAb,CAAoBuF,IAApB,CAAyBH,QAAzB;AACnB,eA1BgC;AA2BjCI,cAAAA,mBAAmB,EAAE,CACnBxF,IADmB,EAEnBoF,QAFmB,KAGhB;AACH,oBAAMC,SAAS,GAAGT,YAAY,CAAC5E,IAAD,CAA9B;AACA,oBAAMuD,KAAK,GAAG8B,SAAS,CAACC,OAAV,CAAkBF,QAAlB,CAAd;AACA,oBAAI7B,KAAK,KAAK,CAAC,CAAf,EAAkBoB,aAAa,CAAC3E,IAAD,CAAb,CAAoByF,MAApB,CAA2BlC,KAA3B,EAAkC,CAAlC;AACnB,eAlCgC;AAmCjCyB,cAAAA,aAAa,EAAGU,KAAD,IAAwB;AACrC,oBAAIL,SAAS,GAAGT,YAAY,CAACc,KAAK,CAAC1F,IAAP,CAAZ,CAAyB2F,KAAzB,EAAhB;;AACA,qBAAK,IAAIhE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG0D,SAAS,CAAC5D,MAA9B,EAAsCE,CAAC,EAAvC;AACE0D,kBAAAA,SAAS,CAAC1D,CAAD,CAAT,CAAaiE,IAAb,CAAkB,KAAlB,EAAwBF,KAAxB;AADF;;AAEA,uBAAO,CAACA,KAAK,CAACG,gBAAd;AACD;AAxCgC,eAyC9BjC,eAAe,EAzCe,CAAnC;;AA2CA7D,YAAAA,IAAI,CAACoF,gBAAL,GAAwBpF,IAAI,CAACoF,gBAAL,CAAsBW,IAAtB,CAA2B/F,IAA3B,CAAxB;AACAA,YAAAA,IAAI,CAACyF,mBAAL,GAA2BzF,IAAI,CAACyF,mBAAL,CAAyBM,IAAzB,CAA8B/F,IAA9B,CAA3B;AACAA,YAAAA,IAAI,CAACiF,aAAL,GAAqBjF,IAAI,CAACiF,aAAL,CAAmBc,IAAnB,CAAwB/F,IAAxB,CAArB;AACAA,YAAAA,IAAI,CAACwC,IAAL,GAAYxC,IAAI,CAACwC,IAAL,CAAUuD,IAAV,CAAe/F,IAAf,CAAZ;AACA,mBAAOA,IAAP;AACD,WA9DD;AA+DD,SApEkB;;AAqEnB;AACF;AACA;AACEgG,QAAAA,QAAQ,EAAE,kBACRhF,QADQ,EAEqB;AAC7B;AACE8D,YAAAA,EAAE,EAAE;AAAA;AAAA,mCADN;AAEE7E,YAAAA,IAAI,EAAEC,QAAQ,CAACa,QAFjB;AAGEC,YAAAA;AAHF,aAIK6C,eAAe,EAJpB;AAMD,SAjFkB;;AAkFnB;AACF;AACA;AACEoC,QAAAA,QAAQ,EAAE,kBACRjF,QADQ,EAEqB;AAC7B;AACE8D,YAAAA,EAAE,EAAE;AAAA;AAAA,mCADN;AAEE7E,YAAAA,IAAI,EAAEC,QAAQ,CAACY,QAFjB;AAGEE,YAAAA;AAHF,aAIK6C,eAAe,CAAC;AACjB,aAACxD,SAAS,CAACoB,aAAX,GAA2B;AADV,WAAD,CAJpB;AAQD,SAhGkB;;AAiGnB;AACF;AACA;AACEyE,QAAAA,QAAQ,EAAE,kBACRlF,QADQ,EAEqB;AAC7B;AACE8D,YAAAA,EAAE,EAAE;AAAA;AAAA,mCADN;AAEE7E,YAAAA,IAAI,EAAEC,QAAQ,CAACW,QAFjB;AAGEG,YAAAA;AAHF,aAIK6C,eAAe,EAJpB;AAMD,SA7GkB;AA8GnBsC,QAAAA,SAAS,EAAE,mBACT1B,IADS,EAET9B,EAFS,EAGqB;AAC9B;AACEmC,YAAAA,EAAE,EAAE;AAAA;AAAA,mCADN;AAEEL,YAAAA,IAFF;AAGExE,YAAAA,IAAI,EAAEC,QAAQ,CAAC2C,SAHjB;AAIEC,YAAAA,IAAI,EAAE,CAACsD,IAAD,EAAOrE,KAAP,KAAiB;AACrB,kBAAI,OAAOY,EAAP,KAAc,UAAlB,EAA8B;AAC5B,uBAAOA,EAAE,CAACyD,IAAI,CAACnE,KAAN,EAAaF,KAAb,CAAT;AACD,eAFD,MAEO;AACL,uBAAO,IAAP;AACD;AACF;AAVH,aAWK8B,eAAe,EAXpB;AAaD,SA/HkB;AAgInBwC,QAAAA,MAAM,EAAE,kBAAoD;AAC1D;AACEvB,YAAAA,EAAE,EAAE;AAAA;AAAA,mCADN;AAEE7E,YAAAA,IAAI,EAAEC,QAAQ,CAACS,MAFjB;AAGEK,YAAAA,QAAQ,EAAE;AAHZ,aAIK6C,eAAe,EAJpB;AAKEyC,YAAAA,KAAK,EAAE,iBAAW;AAChB,mBAAKtF,QAAL,CAAc0E,MAAd,CAAqB,CAArB,EAAwB,KAAK1E,QAAL,CAAcU,MAAtC;AACA,qBAAO,IAAP;AACD,aARH;AASE6E,YAAAA,KAAK,EAAE,eAASvF,QAAT,EAAiD;AACtD,kBAAI,KAAKA,QAAL,CAAcwF,IAAd,CAAmBnF,IAAI,IAAIA,IAAI,CAACyD,EAAL,KAAY9D,QAAQ,CAAC8D,EAAhD,CAAJ,EAAyD,OAAO,IAAP;AACzD,mBAAK9D,QAAL,CAAcwE,IAAd,CAAmBxE,QAAnB;AACA,qBAAO,IAAP;AACD,aAbH;AAcEyF,YAAAA,OAAO,EAAE,iBAASzF,QAAT,EAAiD;AACxD,kBAAMwC,KAAK,GAAG,KAAKxC,QAAL,CAAc0F,SAAd,CAAwBrF,IAAI,IAAIA,IAAI,CAACyD,EAAL,KAAY9D,QAAQ,CAAC8D,EAArD,CAAd;AACA,mBAAK9D,QAAL,CAAc0E,MAAd,CAAqBlC,KAArB,EAA4B,CAA5B;AACA,qBAAO,IAAP;AACD;AAlBH;AAoBD,SArJkB;AAsJnBvB,QAAAA,KAAK;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA,UAAE,UACLA,KADK,EAELjB,QAFK,EAGqB;AAC1B;AACE8D,YAAAA,EAAE,EAAE;AAAA;AAAA,mCADN;AAEE7E,YAAAA,IAAI,EAAEC,QAAQ,CAAC8C,KAFjB;AAGEhC,YAAAA,QAHF;AAIEiB,YAAAA;AAJF,aAKK4B,eAAe,EALpB;AAOD,SAXI,CAtJc;AAkKnB8C,QAAAA,MAAM,EAAE,gBACN3F,QADM,EAEqB;AAC3B;AACE8D,YAAAA,EAAE,EAAE;AAAA;AAAA,mCADN;AAEE7E,YAAAA,IAAI,EAAEC,QAAQ,CAACU,MAFjB;AAGEI,YAAAA;AAHF,aAIK6C,eAAe,EAJpB;AAMD,SA3KkB;AA4KnB+C,QAAAA,MAAM,EAAE,gBACNnC,IADM,EAEN9B,EAFM,EAGqB;AAC3B;AACEmC,YAAAA,EAAE,EAAE;AAAA;AAAA,mCADN;AAEEL,YAAAA,IAFF;AAGExE,YAAAA,IAAI,EAAEC,QAAQ,CAACC,MAHjB;AAIEwC,YAAAA;AAJF,aAKKkB,eAAe,EALpB;AAOD;AAvLkB,O","sourcesContent":["import nanoid from 'nanoid'\nimport produce, {applyPatches, Patch, enablePatches, Draft} from 'immer'\n\nenablePatches()\n\nexport const enum NodeStatus {\n  Ready = 'Ready',\n  Success = 'Success',\n  Failure = 'Failure',\n  Running = 'Running',\n}\nexport const enum NodeType {\n  Action = 'Action',\n  Condition = 'Condition',\n  Decorator = 'Decorator',\n  Invert = 'Invert',\n  Parallel = 'Parallel',\n  Portal = 'Portal',\n  Root = 'Root',\n  Selector = 'Selector',\n  Sequence = 'Sequence',\n  State = 'State',\n}\nexport const enum _StoreKey {\n  Patches = '$patches',\n  SequenceIndex = '$sequenceIndex',\n  Status = '$status',\n  Count = '$count',\n  WasRun = '$wasRun',\n}\nexport interface INodeState {\n  [_StoreKey.Count]: number\n  [_StoreKey.Status]: NodeStatus\n}\nexport interface INodeTarget {\n  addEventListener: (\n    type: 'tickstart' | 'tickend',\n    listener: () => void\n  ) => void\n  removeEventListener: (\n    type: 'tickstart' | 'tickend',\n    listener: () => void\n  ) => void\n  dispatchEvent: (event: CustomEvent) => boolean\n}\nexport interface IRootNode<State, Props> extends IWithNodeState, INodeTarget {\n  id: string\n  name: string\n  type: NodeType.Root\n  state: State\n  children: ICompositeNode<State, Props>\n  tick: (props?: Props) => NodeStatus | undefined\n}\nexport interface IConditionNode<State, Props> extends IWithNodeState {\n  id: string\n  name: string\n  type: NodeType.Condition\n  parent?: IAnyNode<State, Props>\n  exec(\n    args: {\n      state: State\n      node: IConditionNode<State, Props>\n      root: IRootNode<State, Props>\n    },\n    props: Props\n  ): any\n}\nexport interface IActionNode<State, Props> extends IWithNodeState {\n  id: string\n  name: string\n  type: NodeType.Action\n  fn: (state: State, props: Props) => void | Promise<void>\n  parent?: IAnyNode<State, Props>\n}\nexport interface IStateNode<State, Props> extends IWithNodeState {\n  id: string\n  type: NodeType.State\n  parent?: IAnyNode<State, Props>\n  children: IAnyChildNode<State, Props>\n  state: any\n}\nexport interface IPortalNode<State, Props> extends IWithNodeState {\n  id: string\n  type: NodeType.Portal\n  parent?: IAnyNode<State, Props>\n  children: Array<ICompositeNode<State, Props>>\n  clear: () => IPortalNode<State, Props>\n  mount: (children: ICompositeNode<State, Props>) => IPortalNode<State, Props>\n  unmount: (children: ICompositeNode<State, Props>) => IPortalNode<State, Props>\n}\nexport interface ISequenceNode<State, Props> extends IWithNodeState {\n  id: string\n  type: NodeType.Sequence\n  parent?: IAnyNode<State, Props>\n  children: IAnyChildNode<State, Props>[]\n}\nexport interface IParallelNode<State, Props> extends IWithNodeState {\n  id: string\n  type: NodeType.Parallel\n  parent?: IAnyNode<State, Props>\n  children: IAnyChildNode<State, Props>[]\n}\nexport interface ISelectorNode<State, Props> extends IWithNodeState {\n  id: string\n  type: NodeType.Selector\n  parent?: IAnyNode<State, Props>\n  children: IAnyChildNode<State, Props>[]\n}\nexport interface IDecoratorNode<State, Props> extends IWithNodeState {\n  id: string\n  type: NodeType.Decorator\n  parent?: IAnyNode<State, Props>\n  decorator: (status: NodeStatus) => NodeStatus\n  children: ILeafNode<State, Props>\n}\nexport interface IInvertNode<State, Props> extends IWithNodeState {\n  id: string\n  type: NodeType.Invert\n  parent?: IAnyNode<State, Props>\n  children: IAnyChildNode<State, Props>\n}\nexport type ICompositeNode<State, Props> =\n  | ISelectorNode<State, Props>\n  | ISequenceNode<State, Props>\n  | IParallelNode<State, Props>\n  | IDecoratorNode<State, Props>\n  | IInvertNode<State, Props>\n  | IPortalNode<State, Props>\n  | IStateNode<State, Props>\nexport type ILeafNode<State, Props> =\n  | IActionNode<State, Props>\n  | IConditionNode<State, Props>\nexport type IAnyChildNode<State, Props> =\n  | ICompositeNode<State, Props>\n  | ILeafNode<State, Props>\nexport type IAnyNode<State, Props> =\n  | IRootNode<State, Props>\n  | IAnyChildNode<State, Props>\nexport interface IWithNodeState {\n  $nodeState: INodeState\n  /**\n   * Get value form node state\n   */\n  getValue: <T>(key: string, defaultValue?: T) => T\n  /**\n   * Set value in node state\n   */\n  setValue: (key: string, value: any) => any\n}\nexport type IOptions<Props> = {\n  props?: Props\n  setState: any\n}\n\nexport const nodes = {\n  root: function<State, Props>(\n    name: string,\n    childrenFactory: () => ICompositeNode<State, Props>\n  ) {\n    return (\n      initialState: State,\n      options: IOptions<Props> = {\n        props: {} as Props,\n        setState: () => {},\n      }\n    ): IRootNode<State, Props> => {\n      const registrations: {\n        [key: string]: Array<(event: CustomEvent) => void>\n      } = {}\n      const getListeners = function(type: string) {\n        if (!(type in registrations)) registrations[type] = []\n        return registrations[type]\n      }\n      const root: IRootNode<State, Props> = {\n        id: nanoid(),\n        name,\n        type: NodeType.Root,\n        children: childrenFactory(),\n        state: initialState,\n        tick: function tick(props?: Props) {\n          if (typeof window === 'undefined') {\n            return undefined\n          }\n          this.dispatchEvent(new CustomEvent('tickstart'))\n          const nodeStatus = _interpret(this.children, this, {\n            ...options,\n            props,\n          })\n          _resetFinalStates(this.children, this)\n          this.dispatchEvent(new CustomEvent('tickend'))\n          return nodeStatus\n        },\n        addEventListener: (\n          type: 'tickstart' | 'tickend',\n          listener: () => void\n        ) => {\n          const listeners = getListeners(type)\n          const index = listeners.indexOf(listener)\n          if (index === -1) registrations[type].push(listener)\n        },\n        removeEventListener: (\n          type: 'tickstart' | 'tickend',\n          listener: () => void\n        ) => {\n          const listeners = getListeners(type)\n          const index = listeners.indexOf(listener)\n          if (index !== -1) registrations[type].splice(index, 1)\n        },\n        dispatchEvent: (event: CustomEvent) => {\n          var listeners = getListeners(event.type).slice()\n          for (var i = 0; i < listeners.length; i++)\n            listeners[i].call(this, event)\n          return !event.defaultPrevented\n        },\n        ...createNodeState(),\n      }\n      root.addEventListener = root.addEventListener.bind(root)\n      root.removeEventListener = root.removeEventListener.bind(root)\n      root.dispatchEvent = root.dispatchEvent.bind(root)\n      root.tick = root.tick.bind(root)\n      return root\n    }\n  },\n  /**\n   * Runs child nodes in sequence until it finds one that succeeds. Succeeds when it finds the first child that succeeds. For child nodes that fail, it moves forward to the next child node. While a child is running it stays on that child node without moving forward.\n   */\n  selector: function<State, Props>(\n    children: IAnyChildNode<State, Props>[]\n  ): ISelectorNode<State, Props> {\n    return {\n      id: nanoid(),\n      type: NodeType.Selector,\n      children,\n      ...createNodeState(),\n    }\n  },\n  /**\n   * Runs each child node one by one. Fails for the first child node that fails. Moves to the next child when the current running child succeeds. Stays on the current child node while it returns running. Succeeds when all child nodes have succeeded.\n   */\n  sequence: function<State, Props>(\n    children: IAnyChildNode<State, Props>[]\n  ): ISequenceNode<State, Props> {\n    return {\n      id: nanoid(),\n      type: NodeType.Sequence,\n      children,\n      ...createNodeState({\n        [_StoreKey.SequenceIndex]: 0,\n      }),\n    }\n  },\n  /**\n   * Runs all child nodes in parallel. Continues to run until a required number of child nodes have either failed or succeeded.\n   */\n  parallel: function<State, Props>(\n    children: IAnyChildNode<State, Props>[]\n  ): IParallelNode<State, Props> {\n    return {\n      id: nanoid(),\n      type: NodeType.Parallel,\n      children,\n      ...createNodeState(),\n    }\n  },\n  condition: function<State, Props>(\n    name: string,\n    fn?: (state: State, props: Props) => any\n  ): IConditionNode<State, Props> {\n    return {\n      id: nanoid(),\n      name,\n      type: NodeType.Condition,\n      exec: (args, props) => {\n        if (typeof fn === 'function') {\n          return fn(args.state, props)\n        } else {\n          return true\n        }\n      },\n      ...createNodeState(),\n    }\n  },\n  portal: function<State, Props>(): IPortalNode<State, Props> {\n    return {\n      id: nanoid(),\n      type: NodeType.Portal,\n      children: [],\n      ...createNodeState(),\n      clear: function() {\n        this.children.splice(0, this.children.length)\n        return this\n      },\n      mount: function(children: ICompositeNode<State, Props>) {\n        if (this.children.find(item => item.id === children.id)) return this\n        this.children.push(children)\n        return this\n      },\n      unmount: function(children: ICompositeNode<State, Props>) {\n        const index = this.children.findIndex(item => item.id === children.id)\n        this.children.splice(index, 1)\n        return this\n      },\n    }\n  },\n  state: function<State, Props>(\n    state: any,\n    children: IAnyChildNode<State, Props>\n  ): IStateNode<State, Props> {\n    return {\n      id: nanoid(),\n      type: NodeType.State,\n      children,\n      state,\n      ...createNodeState(),\n    }\n  },\n  invert: function<State, Props>(\n    children: IAnyChildNode<State, Props>\n  ): IInvertNode<State, Props> {\n    return {\n      id: nanoid(),\n      type: NodeType.Invert,\n      children,\n      ...createNodeState(),\n    }\n  },\n  action: function<State, Props>(\n    name: string,\n    fn: (state: State, props: Props) => void\n  ): IActionNode<State, Props> {\n    return {\n      id: nanoid(),\n      name,\n      type: NodeType.Action,\n      fn,\n      ...createNodeState(),\n    }\n  },\n}\n\nfunction _resetFinalStates<State, Props>(\n  node: IAnyNode<State, Props>,\n  root: IRootNode<State, Props>\n) {\n  switch (node.type) {\n    case NodeType.Action:\n      if (!node.getValue(_StoreKey.WasRun)) {\n        node.setValue(_StoreKey.Status, NodeStatus.Ready)\n      }\n      break\n    case NodeType.Portal:\n    case NodeType.Invert:\n    case NodeType.Parallel:\n    case NodeType.Sequence:\n    case NodeType.Selector: {\n      // TODO: Clean up this logic\n\n      const children = Array.isArray(node.children)\n        ? node.children\n        : [node.children]\n      const hasRunningChildren = children.some(\n        item => item.getValue(_StoreKey.Status) === NodeStatus.Running\n      )\n      const isSequence = node.type === NodeType.Sequence\n      const hasSequenceFinished = isSequence\n        ? node.getValue<number>(_StoreKey.SequenceIndex) + 1 ===\n            children.length || node.getValue(_StoreKey.WasRun) === false\n        : true\n\n      if (!hasRunningChildren && hasSequenceFinished) {\n        node.setValue(_StoreKey.Status, NodeStatus.Ready)\n\n        if (node.type === NodeType.Sequence) {\n          node.setValue(_StoreKey.SequenceIndex, 0)\n        }\n\n        children.forEach(item => {\n          item.setValue(_StoreKey.Status, NodeStatus.Ready)\n        })\n      }\n\n      for (let i = 0; i < children.length; i++) {\n        _resetFinalStates(children[i], root)\n      }\n      break\n    }\n    default:\n      break\n  }\n\n  node.setValue(_StoreKey.WasRun, false)\n}\n\nfunction _interpret<State, Props>(\n  node: IAnyNode<State, Props>,\n  root: IRootNode<State, Props>,\n  options: IOptions<Props> = {\n    props: {} as Props,\n    setState: () => {},\n  }\n): NodeStatus {\n  const {state} = root\n  node.setValue(_StoreKey.WasRun, true)\n\n  switch (node.type) {\n    case NodeType.Action: {\n      const status = node.getValue<NodeStatus>(_StoreKey.Status)\n\n      // This is an async action\n      if (status === NodeStatus.Running) {\n        const patches = node.getValue<Patch[]>(_StoreKey.Patches)\n\n        // If patches is not undefined then action has resolved and we can apply it's result to current state\n        if (patches) {\n          // Apply patches to current state\n          const nextState = applyPatches(state, patches)\n          // Reset patches array\n          node.setValue(_StoreKey.Patches, undefined)\n          node.setValue(_StoreKey.Status, NodeStatus.Success)\n          root.state = nextState\n          options.setState?.(nextState)\n          root.tick(options.props)\n\n          return NodeStatus.Success\n        }\n\n        return status\n      }\n\n      bump(node)\n\n      const nextState = produce(\n        state,\n        draft => node.fn(draft as State, options.props || ({} as Props)),\n        patches => {\n          node.setValue(_StoreKey.Patches, patches)\n\n          if (isPromise(nextState)) {\n            root.tick()\n          }\n        }\n      )\n\n      if (isPromise(nextState)) {\n        node.setValue(_StoreKey.Status, NodeStatus.Running)\n\n        return NodeStatus.Running\n      }\n\n      // TODO: Handle errors(failure status)\n\n      root.state = nextState as State\n      options.setState?.(nextState)\n      node.setValue(_StoreKey.Status, NodeStatus.Success)\n      return NodeStatus.Success\n    }\n    case NodeType.Condition: {\n      bump(node)\n      node.setValue(_StoreKey.Status, NodeStatus.Running)\n      if (\n        node.exec(\n          {\n            state,\n            node,\n            root,\n          },\n          options.props || ({} as Props)\n        )\n      ) {\n        node.setValue(_StoreKey.Status, NodeStatus.Success)\n        return NodeStatus.Success\n      } else {\n        node.setValue(_StoreKey.Status, NodeStatus.Failure)\n        return NodeStatus.Failure\n      }\n    }\n    case NodeType.Invert: {\n      bump(node)\n      node.setValue(_StoreKey.Status, NodeStatus.Running)\n      const status = _interpret(node.children, root, options)\n      if (status === NodeStatus.Failure) {\n        node.setValue(_StoreKey.Status, NodeStatus.Success)\n        return NodeStatus.Success\n      }\n      if (status === NodeStatus.Success) {\n        node.setValue(_StoreKey.Status, NodeStatus.Failure)\n        return NodeStatus.Failure\n      }\n      return status\n    }\n    case NodeType.State: {\n      bump(node)\n      return _interpret(node.children, root, options)\n    }\n    case NodeType.Decorator: {\n      bump(node)\n      return node.decorator(_interpret(node.children, root, options))\n    }\n    case NodeType.Portal:\n    case NodeType.Parallel: {\n      bump(node)\n      node.setValue(_StoreKey.Status, NodeStatus.Running)\n      let states = []\n\n      for (let i = 0; i < node.children.length; i++) {\n        node.children[i].parent = node\n        states[i] = _interpret(node.children[i], root, options)\n      }\n      // TODO: Make this a prop\n      const nSuccess = states.filter(status => status === NodeStatus.Success)\n        .length\n      // TODO: Make this a prop\n      const nFailure = states.filter(status => status === NodeStatus.Failure)\n        .length\n\n      if (nSuccess === node.children.length) {\n        node.setValue(_StoreKey.Status, NodeStatus.Success)\n        return NodeStatus.Success\n      } else if (nFailure === node.children.length) {\n        node.setValue(_StoreKey.Status, NodeStatus.Failure)\n        return NodeStatus.Failure\n      }\n      node.setValue(_StoreKey.Status, NodeStatus.Running)\n      return NodeStatus.Running\n    }\n    case NodeType.Sequence: {\n      bump(node)\n      node.setValue(_StoreKey.Status, NodeStatus.Running)\n      let index = node.getValue<number>(_StoreKey.SequenceIndex, 0)\n      while (index < node.children.length) {\n        const child = node.children[index]\n        child.parent = node\n        const status = _interpret(child, root, options)\n\n        if (status === NodeStatus.Success) {\n          node.setValue(_StoreKey.SequenceIndex, ++index)\n          continue\n        } else if (status === NodeStatus.Running) {\n          node.setValue(_StoreKey.Status, NodeStatus.Running)\n          return NodeStatus.Running\n        } else if (status === NodeStatus.Failure) {\n          node.setValue(_StoreKey.SequenceIndex, 0)\n          node.setValue(_StoreKey.Status, NodeStatus.Failure)\n          return NodeStatus.Failure\n        }\n      }\n      node.setValue(_StoreKey.SequenceIndex, 0)\n      node.setValue(_StoreKey.Status, NodeStatus.Success)\n      return NodeStatus.Success\n    }\n    case NodeType.Selector: {\n      bump(node)\n      node.setValue(_StoreKey.Status, NodeStatus.Running)\n\n      for (const child of node.children) {\n        child.parent = node\n        const status = _interpret(child, root, options)\n        if (status === NodeStatus.Success || status === NodeStatus.Running) {\n          node.setValue(_StoreKey.Status, status)\n          return status\n        }\n      }\n      node.setValue(_StoreKey.Status, NodeStatus.Failure)\n      return NodeStatus.Failure\n    }\n    default:\n      throw new Error('Invalid node type!')\n  }\n}\n\nfunction bump(node: IAnyNode<any, any>) {\n  const currentValue = node.getValue<number>(_StoreKey.Count, 0)\n  node.setValue(_StoreKey.Count, currentValue + 1)\n}\n\nfunction createNodeState(customState?: any) {\n  return {\n    $nodeState: {\n      [_StoreKey.Count]: 0,\n      [_StoreKey.WasRun]: false,\n      [_StoreKey.Status]: NodeStatus.Ready,\n      ...customState,\n    },\n    setValue(key: string, value: any) {\n      this['$nodeState'][key] = value\n    },\n    getValue<Value>(key: string, defaultValue?: any): Value {\n      if (this['$nodeState'] === undefined) {\n        return defaultValue === undefined ? undefined : defaultValue\n      }\n      return this['$nodeState'][key] === undefined\n        ? defaultValue\n        : this['$nodeState'][key]\n    },\n  }\n}\n\nfunction isPromise(item: any): boolean {\n  return item && typeof item.then === 'function'\n}\n"]}